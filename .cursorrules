# Aivolution Projekt-Regeln

## Design-Vorgaben (Brand-Identity)
- Stil: Futuristisch-modern, brutalistisch.
- Elemente: Abgerundete Ecken [2.5rem], starke Kontraste.
- Farbschema: Schwarz, Rot, Weiß.
- Qualitätsanspruch: "Crunchy" und hochwertig, kein Standard-Template-Look.
- **UI-Philosophie:** Dezent und clean. Lieber kleine Menüs/Panels als wuchtige Elemente.

## Plattform-Architektur & Features

### Rollen-System (3 Ebenen):
1. **user:** Basis-Account (Community nutzen, kaufen) - kein Verkauf
2. **creator:** User nach Onboarding-Freischaltung (kann verkaufen)
3. **moderation:** Moderatoren (können Inhalte kuratieren, Profile pausieren, Songs/Alben löschen)
4. **admin:** Vollzugriff (kann alles + Moderatoren verwalten)

### Creator-Onboarding Workflow (BEST PRACTICE):
**WICHTIG:** Bevorzuge IMMER diesen schlanken Flow (keine Multi-Step-Formulare mit Redirects).

**Phase 1: Registrierung**
- Route: `/creator-signup`
- AGBs/Richtlinien als Checkbox (vereinfacht, zentral in der Form)
- Email + Passwort + Artist Name
- Nach Signup: Profil wird CLIENT-SIDE erstellt (Session ist aktiv!)
- Status: `onboarding_status = 'pending'`

**Phase 2: Profil-Erstellung (All-in-One)**
- Gleiche Route, Step 2 nach erfolgreicher Auth
- **EIN Formular** (nicht Steps!) mit:
  - Avatar Upload, Bio, Tech-Stack (Multi-Select), Social Links
  - 2 Songs hochladen (MP3, max 10MB)
  - Genre-Tags (max 3 pro Song)
- **Speichern:** 
  1. Avatar + Songs zu Supabase Storage
  2. Profile UPDATE (bio, tech_stack, social_links, avatar_url)
  3. Songs INSERT (2 Einträge, `is_probe = true`)
  4. Status: `onboarding_status = 'submitted'`
- Redirect: `/?status=pending` (Homepage mit Lock-Symbol-Hinweis)

**Phase 3: Freischaltung**
- Admin prüft in `/admin/applications` (Songs anhören, Profil checken)
- Automatischer Filter läuft bei Submit (Bad-Words via `check_content_safety` RPC)
- Admin klickt "Approve" → Server Action:
  - `onboarding_status = 'approved'`
  - `role = 'creator'`
  - Trigger generiert automatisch `artist_name_slug` für Creator-Profil-URL
- Creator bekommt Email-Benachrichtigung (TODO)

**Technische Vorteile:**
- Weniger Redirects (stabiler)
- Weniger DB-Calls (performanter)
- Client-Side Profile-Creation (RLS funktioniert, weil Session aktiv)
- Einfacher zu debuggen (weniger Moving Parts)
- Klarer Status-Flow (pending → submitted → approved)

**Dateien:**
- `/src/app/creator-signup/page.tsx` - Registrierung + Profil-Form
- `/src/app/creator/[slug]/page.tsx` - Creator-Profil (öffentlich)
- `/src/app/admin/applications/page.tsx` - Admin Review
- `supabase_creator_profile_v2.sql` - Slug-Generierung (Trigger)

### Admin/Moderation-Funktionen (Kommandozentrale):
- **Kuration:**
  - Namenssuche (Suchleiste für Creator-Profile)
  - Bewerbungen prüfen & freischalten/ablehnen
  - **Direkt-Editierung:** Als Admin direkt in fremden Profilen editieren können
  - Profile pausieren/sperren
  - Songs & Alben löschen
- **Design:** Dezente Suchleiste, kompakte Panels (nicht zu wuchtig)

### RLS (Row Level Security):
- User: Nur eigene Daten sehen/editieren
- Moderation: Alle Creator-Daten sehen, editieren, pausieren
- Admin: Vollzugriff + Moderatoren-Verwaltung

## Masterfragen v2 (verbindlich vor jedem Feature/Fix)
1. **Scaling (Performance):** Funktioniert der Ablauf auch mit 100.000+ Datensätzen (Pagination, Indizes, schlanke Queries)?
2. **Security (RLS):** Sind RLS-Policies strikt genug, sodass User nur eigene Daten lesen/ändern können?
3. **Schema-Realität:** Existieren alle benötigten Tabellen/Spalten/Funktionen/Policies wirklich in der Ziel-DB (kein "angenommenes Schema")?
4. **Murphy's Law (Stabilität):** Was passiert bei Abbruch mitten im Prozess (Browser zu, Upload abgebrochen, Timeout)?
5. **Idempotenz:** Ist der Prozess erneut ausführbar, ohne doppelte Datensätze/Seiteneffekte zu erzeugen?
6. **Observability/Debug:** Gibt es klare Logs/Statusmeldungen, damit Fehler schnell lokalisierbar sind?
7. **Tech-Stack-Fit:** Ist die Umsetzung mit aktuellem Next.js App Router + Supabase Best Practices gebaut?
8. **Build-Integrität:** Sind alle Pfade/Dateinamen/Imports korrekt (keine Tippfehler, keine Case-/Leerzeichen-Fallen)?
9. **UX-Flow (schlank):** Ist der Nutzerfluss maximal einfach (wenige Schritte, klare CTAs, eindeutige Rückmeldungen)?
10. **Brand-Identity:** Entspricht UI/UX dem Aivolution-Stil (brutalistisch, hochwertig, 2.5rem Corners)?
11. **Legal/Compliance:** Sind DSGVO/TMG/Urheberrechts-Risiken berücksichtigt (Datensparsamkeit, Nachweisbarkeit, Löschpfade)?
12. **Betrieb/Kosten:** Ist die Lösung ressourcenschonend und für den aktuellen Budget-Rahmen tragfähig?
13. **Schema-Kompatibilität:** Nutzt der Code nur DB-Felder/Funktionen, die in der Zielumgebung verifiziert existieren (z.B. `updated_at` nicht blind voraussetzen)?
14. **Link-Integrität:** Sind kritische Zielpfade (z.B. `/creator/[slug]`) mit Fallback robust und in Runtime wirklich erreichbar?

## Verbindliche Preflight-Routine (vor "Fertig")
1. **DB-Precheck:** `information_schema`, `pg_proc`, `pg_policies` prüfen, ob alle benötigten Objekte existieren.
2. **Idempotente SQL:** Nur mit `IF EXISTS` / `IF NOT EXISTS` arbeiten, damit wiederholte Ausführung sicher ist.
3. **Datei-/Import-Check:** Prüfen, ob alle referenzierten Dateien/Ordner wirklich vorhanden sind.
4. **Routen-Check:** Alle betroffenen Pfade manuell gegenklicken (Happy Path + 1 Fehlerpfad).
5. **Lint/Build-Check:** Keine neuen Lint-/Build-Fehler hinterlassen.
6. **RLS-Quickcheck:** Für betroffene Tabellen mindestens Owner-, Fremduser- und Admin-Fall denken.
7. **Definition of Done:** Fix gilt erst als "fertig", wenn Code, DB und Runtime-Flow zusammen erfolgreich sind.
8. **No-Hard-Dependency auf optionale Spalten:** Keine harte Abhängigkeit auf Felder wie `updated_at`, wenn Schema-Drift möglich ist.
9. **Live-Link-Test:** Der echte Endlink des Flows (z.B. Creator-Profil-URL aus Kuration) muss in der Zielumgebung erfolgreich laden.
10. **Slug-Konsistenz:** Alle Slugs (URLs) MÜSSEN lowercase sein, erzwungen auf 3 Ebenen:
    - **Code:** Immer `.toLowerCase()` bei Slug-Generierung
    - **DB:** CHECK constraint für lowercase in der Tabelle
    - **Queries:** `.ilike()` statt `.eq()` für case-insensitive Lookups

## Tech-Stack-Spezifika (Next.js 16 + Codespaces)
**WICHTIG:** Diese Erkenntnisse sind verifiziert und dürfen NICHT durch veraltete Lösungen ersetzt werden.

### Next.js 16 Anforderungen:
- **Proxy statt Middleware:** Dateiname muss `src/proxy.ts` heißen (NICHT `middleware.ts`).
  - Export: `export default async function proxy(request: NextRequest) { ... }`
  - Grund: Next.js 16 hat "middleware" deprecated zugunsten von "proxy".
  
### Codespaces Setup:
- **Server Actions Config:** `next.config.ts` MUSS `serverActions.allowedOrigins` enthalten:
  ```ts
  experimental: {
    serverActions: {
      allowedOrigins: ['localhost:3000', '*.app.github.dev']
    }
  }
  ```
  - Ohne diese Config gibt es "Invalid Server Actions request" Fehler.
  
- **Port 3000 ist Pflicht:** Die Codespace-URL endet auf `-3000.app.github.dev`.
  - Bei Port-Konflikten: `pkill -f node` und neu starten.
  - Cache-Probleme: `rm -rf .next` vor Neustart.

### Supabase Integration:
- **Admin-Check:** Immer via `supabase.rpc('get_my_role')` (NICHT direkter Tabellen-Zugriff).
  - Grund: Umgeht RLS-Probleme und Spalten-Permissions.
  
### Deployment-Workflow (lokal → Codespace):
1. Lokal: `git add . && git commit -m "..." && git push origin main`
2. Codespace: `git pull` + Server neu starten
3. **KEINE** alternativen Sync-Methoden verwenden (führt zu Inkonsistenzen).

## Arbeitsweise
- Gib immer den vollständig adaptierten Code aus.
- Optimiere nicht nur den Schreibstil, sondern achte auf saubere Struktur, damit der Code nicht "unclean" wird.
- Nutze die informelle Du-Form.
- **Bei Fehlern:** Prüfe ZUERST die "Tech-Stack-Spezifika" oben, bevor alte Lösungen angewendet werden.
